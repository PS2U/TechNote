# 3.1 进程

进程就是处于执行期的程序，但进程不仅仅局限于一段可执行程序代码，还包括其他资源，像打开的文件、挂起的信号、内核内部数据、处理器状态、内存地址空间、执行线程。

执行线程，是进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈、一组进程寄存器。内核调度的对象是线程，而不是进程。Linux系统的线程实现非常特别：**它对线程和进程并不特别区分**。

进程提供两种虚拟机制：虚拟处理器和虚拟内存。许多进程分享一个处理器，虚拟处理器给进程一种假象，让进程觉得自己在独占处理器。虚拟内存让进程在分配和管理内存时觉得自己拥有所有的内存资源。

进程在创建它的时刻开始存活，这是`fork()`的结果。该系统调用通过复制一个现有进程来创建一个新的进程。创建新的进程都是为了立即执行新的、不同的程序，接着调用`exec()`这组函数就可以创建新的地址空间，并把新的程序载入其中。现代Linux内核中，`fork()`实际上是由`clone()`系统调用实现的。

最终，程序通过`exit()`退出执行，这个系统调用会终结进程并释放占用的资源。父进程可以通过`wait4()`查询子进程是否终结。进程退出执行后被设置为僵死状态，知道它的父进程调用`wait()`或`waitpid()`为止。

# 3.2 进程描述符及任务结构

内核把进程的列表存放在任务队列中，队列是一个双向循环链表，每个元素都是类型为`task_struct`，成为进程描述符的结构。该结构定义在`<linux/sched.h>`文件中。进程描述符包含了一个具体进程的所有信息：

- 打开的文件
- 进程的地址空间
- 挂起的信号
- 进程的状态

## 分配进程描述符

Linux通过slab分配器分配`task_struct`结构，这样就达到了对象复用和缓存着色（cache coloring）的目的。slab分配器动态生成`task_struct`，只需在栈底或栈顶创建新歌新的结构`struct thread_info`。

```c
// <asm/thread_info.h>

struct thread_info {
  struct task_struct *task;
  struct exec_domain *exec_domain;
  __u32 flags;
  __u32 status;
  __u32 cpu;
  int preempt_count;
  mm_segment_t addr_limit;
  struct restart_block restart_block;
  void *sysenter_return;
  int uaccess_err;
};
```

![](img/chap2/img0.png)

每个任务的`thread_info`结构在它的内核栈的尾端分配，结构中的`task`存放的是指向该任务实际`task_struct`的指针。

## 进程描述符的存放

内核通过一个唯一的进程标识值（PID）来标识每个进程。PID是一个数，标识为`pid_t`隐含类型，实际就是一个`int`。内核把每个进程的PID存放在各自的进程描述符中。PID的最大值默认为32768（short int的最大值），这个限制在`<linux/threads.h>`定义。

内核中，访问任务通常需要获得指向其`task_struct`的指针。通过`current`宏查找当前正在运行进程的进程描述符。不同的硬件结构有不同的实现。

## 进程状态

进程描述符中的`state`描述了当前进程的状态:

- TASK_RUNNING。进程是可执行的，要么正在执行，要么在运行队列中等待执行。这是进程在用户空间中执行的唯一可能的状态。
- TASK_INTERRUPTIBLE。进程被阻塞，等待某个条件的达成。一旦条件达成或者被信号提前唤醒，内核就会把进程状态设置为运行。
- TASK_UNINTERRUPTIBLE。除了就算是接收到信号也不会被唤醒或准备投入运行外，这个状态与`TASK_INTERRUPTIBLE`相同。
- __TASK_TRACED。被其他进程追踪的进程，例如通过`ptrace`对调试程序进行跟踪。
- __TASK_STOPPED。进程停止执行，进程没有投入运行也不能投入运行。通常这种状态发生在接收到`SIGSTOP`、`SIGTSTP`、`SIGTTIN`、`SIGTOU`等信号的时候。此外，在调试期间接收到任何信号，都会使进程进入这种状态。

![](img/chap2/img1.png)

##  设置当前进程状态

内核调整某个进程的状态，使用`set_task_state(task, state)`函数。必要的时候，它会设置内存屏障来强制其他处理器做重新排序（一般只有SMP系统有此必要）。

## 进程上下文

一般程序在用户空间执行，当一个程序执行了系统调用或者触发了某个异常，它就陷入了内核空间。此时，内核『代表进程执行』并处于进程上下文中。在此上下文中，`current`宏是有效的。

## 进程家族树

Unix系统的进程之间存在明显的继承关系。所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init，该进程读取系统的初始化脚本（initscript）并执行其它的相关程序，最终完成系统启动的整个过程。

每个进程必有一个父进程，每个进程可以有0到多个子进程。进程间的关系存放在进程描述符中。`task_struct`有一个指向父进程`task_struct`的`parent`指针，还有一个`children`子进程链表。

init进程的进程描述符是作为`init_task`静态分配的。

在这种继承关系中，从任意一个进程都可以查找到指定的其他进程。

# 3.3 进程创建



# 导航

[目录](README.md)

上一章：[2. 从内核出发](2. 从内核出发.md)

下一章：
