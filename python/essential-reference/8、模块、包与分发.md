# 8.1 Modules and the `import` Statement

Any Python source file can be used as a module. `import` does 3 things:

1. It creates a new namespace that serves as a container for all the objects defined in the corresponding source file.This is the namespace accessed when functions and methods defined within the module use the `global` statement.
2. It executes the code contained in the module within the newly created namespace.
3. It creates a name within the caller that refers to the module namespace.

**It is important to emphasize that import executes all of the statements in the loaded source file.**

To import multiple modules:

```python
import socket, os, re
```

The name used to refer to a module can be changed using the `as` qualifier:

```python
import socket as net
net.gethostname()
```

Modules are first class objects in Python.This means that they can be assigned to variables, placed in data structures such as a list, and passed around in a program as a data.

The `import` statement can appear at any point in a program. However, the code in each module is loaded and executed only once. Subsequent `import` statements simply bind the module name to the module object already created by the previous import. You can find a dictionary containning all currently loaded modules in the variable `sys.modules`.


# 8.2 Importing Selected Symbols from a Module

The from statement is used to load specific definitions within a module into the current namespace.

```python
from spam import foo # Imports spam and puts 'foo' in current namespace
foo() # Calls spam.foo()
spam.foo() # NameError: spam
```

If you have a very long list of names to import, the names can be enclosed in parentheses.

```python
from spam import (foo,
                    bar,
                    Spam)
```

The asterisk (*) wildcard character can also be used to load all the definitions in a module, except those that start with an underscore.

```python
from spam import *
```

Modules can more precisely control the set of names imported by `from module import *` by defining the list `__all__`. 

```python
# module: spam.py
__all__ = [ 'bar', 'Spam' ] # Names I will export with from spam import *
```

Importing definitions with the `form` form of import dose NOT change their scoping rules.

```python
from spam import bar
def foo():
    print("I'm a different foo")
bar()   # When bar calls foo(), it calls spam.foo(), not
        # the definition of foo() above
```

Another confusion with the `from` form of import concerns of behavior of global variables.

```python
from spam import a, foo # Import a global variable
a = 42 # Modify the variable
foo() # Prints "I'm foo and a is 37"
print(a) # Prints "42"
```


# 8.3 Execution as the Main Program

Code might execute as the main program or script: `python spam.py`.

Each module defines a variable, `__name__`, that contains the module name. The top-level module of the interpreter is named `__main__`. Programs specified on the command line or entered interactively run inside the `__main__` module. Sometimes a program may alter its behavior, depending on whether it has been imported as a module or is running in `__main__`.

```python
# Check if running as a program
if __name__ == '__main__':
    # Yes
    statements
else:
    # No, I must have been imported as a module
    statements
```


# 8.4 The Module Search Path

When loading modules, the interpreter searches the list of directories in `sys.path`. 

The first entry in `sys.path` is typically an empty string '', which refers to the current working directory. Other entries in `sys.path` may consist of directory names, `.zip` archive files, and `.egg` files.The order in which entries are listed in sys.path determines the search order used when modules are loaded.To add new entries to the search path, simply add them to this list.

```python
import sys
sys.path.append("mymodules.zip")
import foo, bar
```

`.egg` files are packages created by the `setuptools` library. An `.egg` file is actually just a `.zip` file with some extra metadata.

There are some restrictions about zip file:

1. it only imports `.py`, `.pyc`, `.pyw` and `.pyo` files from archive, not including shared libraries and extension modules written in C.
2. Python will not create .pyc and .pyo files when .py files are loaded from an archive.Thus, it is important to make sure these files are created in advance and placed in the archive in order to avoid poor performance when loading modules.


# 8.5 Module Loading and Compilation

Modules loaded with import really fall into four general categories:

1. Code written in Python (.py files)
2. C or C++ extensions that have been compiled into shared libraries or DLLs
3. Packages containing a collection of modules
4. Built-in modules written in C and linked into the Python interpreter

When looking for a module (for example, `foo`), the interpreter searches each of the directories in `sys.path` for the following files (listed in search order):

1. A directory, `foo`, defining a package
2. `foo.pyd`, `foo.so`, `foomodule.so`, or `foomodule.dll` (compiled extensions)
3. `foo.pyo` (only if the `-O` or `-OO` option has been used)
4. `foo.pyc`
5. `foo.py` (on Windows, Python also checks for `.pyw` files.)

For `.py` files, when a module is first imported, it’s compiled into bytecode and written back to disk as a `.pyc` file. On subsequent imports, the interpreter loads this precompiled bytecode unless the modification date of the `.py` file is more recent (in which case, the `.pyc` file is regenerated).

`.pyo` files are used in conjunction with the interpreter’s -O option.These files contain bytecode stripped of line numbers, assertions, and other debugging information.

If `.pyc` and `.pyo` files are available, it is not necessary for a corresponding `.py` file to exist. Also, be aware that `.pyc` files tend to be version-specific.


# 8.6 Module Reloading and Unloading


