# 8.1 Modules and the `import` Statement

Any Python source file can be used as a module. `import` does 3 things:

1. It creates a new namespace that serves as a container for all the objects defined in the corresponding source file.This is the namespace accessed when functions and methods defined within the module use the `global` statement.
2. It executes the code contained in the module within the newly created namespace.
3. It creates a name within the caller that refers to the module namespace.

**It is important to emphasize that import executes all of the statements in the loaded source file.**

To import multiple modules:

```python
import socket, os, re
```

The name used to refer to a module can be changed using the `as` qualifier:

```python
import socket as net
net.gethostname()
```

Modules are first class objects in Python.This means that they can be assigned to variables, placed in data structures such as a list, and passed around in a program as a data.

The `import` statement can appear at any point in a program. However, the code in each module is loaded and executed only once. Subsequent `import` statements simply bind the module name to the module object already created by the previous import. You can find a dictionary containning all currently loaded modules in the variable `sys.modules`.


# 8.2 Importing Selected Symbols from a Module

The from statement is used to load specific definitions within a module into the current namespace.

```python
from spam import foo # Imports spam and puts 'foo' in current namespace
foo() # Calls spam.foo()
spam.foo() # NameError: spam
```

If you have a very long list of names to import, the names can be enclosed in parentheses.

```python
from spam import (foo,
                    bar,
                    Spam)
```

The asterisk (*) wildcard character can also be used to load all the definitions in a module, except those that start with an underscore.

```python
from spam import *
```

Modules can more precisely control the set of names imported by `from module import *` by defining the list `__all__`. 

```python
# module: spam.py
__all__ = [ 'bar', 'Spam' ] # Names I will export with from spam import *
```

Importing definitions with the `form` form of import dose NOT change their scoping rules.

```python
from spam import bar
def foo():
    print("I'm a different foo")
bar()   # When bar calls foo(), it calls spam.foo(), not
        # the definition of foo() above
```

Another confusion with the `from` form of import concerns of behavior of global variables.

```python
from spam import a, foo # Import a global variable
a = 42 # Modify the variable
foo() # Prints "I'm foo and a is 37"
print(a) # Prints "42"
```


# 8.3 Execution as the Main Program

