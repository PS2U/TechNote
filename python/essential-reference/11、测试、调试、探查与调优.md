In Python, you will never really know if your program is correct until you run and test it. Not only that, unless you are able to run your program in a way that executes every possible branch of its internal control-flow, there is always some chance of a hidden error just waiting to strike.

# 11.1 Documentation Strings and the `doctest` Module

If the first line of a function, class, or module is a string, that string is known as a documentation string. The `help()` command inspects documentation strings, and Python IDEs look at the strings as well.

```python
# splitter.py
def split(line, types=None, delimiter=None):
    """Splits a line of text and optionally performs type conversion.
        For example:
        >>> split('GOOG 100 490.50')
        ['GOOG', '100', '490.50']
        >>> split('GOOG 100 490.50',[str, int, float])
        ['GOOG', 100, 490.5]
        >>>
        By default, splitting is performed on whitespace, but a different
        delimiter can be selected with the delimiter keyword argument:
        >>> split('GOOG,100,490.50',delimiter=',')
        ['GOOG', '100', '490.50']
        >>>
    """
    fields = line.split(delimiter)
    if types:
        fields = [ ty(val) for ty,val in zip(types,fields) ]
    return fields
```

A common problem with writing documentation is keeping the documentation synchronized with the actual implementation of a function. To address this problem, use the `doctest` module. `doctest` collects documentation strings, scans them for interactive sessions, and executes them as a series of tests. To use doctest, you typically create a separate module for testing. For example, if the previous function is in a file `splitter.py`, you would create a file `testsplitter.py` for testing, as follows:

```python
# testsplitter.py
import splitter
import doctest
nfail, ntests = doctest.testmod(splitter)
```

`doctest` expects the output of functions to literally match the exact output you get in the interactive interpreter.

```python
def half(x):
    """Halves x. For example:
    >>> half(6.8)
    3.4
    >>>
    """
    return x/2
```

If you run `doctest` on this function, you will get a failure report such as this:

```
**********************************************************************
File "half.py", line 4, in _ _main_ _.half
Failed example:
    half(6.8)
Expected:
    3.4
Got:
    3.3999999999999999
**********************************************************************
```


# 11.2 Unit Testing and the `unittest` Module

With unit testing, a developer writes a collection of isolated test cases for each element that makes up a program.

```python
# splitter.py
def split(line, types=None, delimiter=None):
    """Splits a line of text and optionally performs type conversion.
    ...
    """
    fields = line.split(delimiter)
    if types:
        fields = [ ty(val) for ty,val in zip(types,fields) ]
    return fields
```

```python
# testsplitter.py
import splitter
import unittest

# Unit tests
class TestSplitFunction(unittest.TestCase):
    def setUp(self):
        # Perform set up actions (if any)
        pass
    def tearDown(self):
        # Perform clean-up actions (if any)
        pass
    def testsimplestring(self):
        r = splitter.split('GOOG 100 490.50')
        self.assertEqual(r,['GOOG','100','490.50'])
    def testtypeconvert(self):
        r = splitter.split('GOOG 100 490.50',[str, int, float])
        self.assertEqual(r,['GOOG', 100, 490.5])
    def testdelimiter(self):
        r = splitter.split('GOOG,100,490.50',delimiter=',')
        self.assertEqual(r,['GOOG','100','490.50'])

# Run the unittests
if _ _name_ _ == '_ _main_ _':
    unittest.main()
```

To run tests, simply run Python on the file `testsplitter.py`. Hereâ€™s an example:

```
% python testsplitter.py
...
----------------------------------------------------------------------
Ran 3 tests in 0.014s
OK
```

Basic use of unittest involves defining a class that inherits from `unittest.TestCase`. Within this class, individual tests are defined by methods starting with the name 'test'.

An instance, `t`, of `unittest.TestCase` has the following methods that are used when writing tests and for controlling the testing process:

`t.setUp()`
Called to perform set-up steps prior to running any of the testing methods. |

`t.tearDown()`
Called to perform clean-up actions after running the tests. |

`t.assert_(expr [, msg])`
`t.failUnless(expr [, msg])`
Signals a test failure if expr evaluates as False. msg is a message string giving an explanation for the failure (if any).

`t.assertEqual(x, y [,msg])`
`t.failUnlessEqual(x, y [, msg])`
Signals a test failure if x and y are not equal to each other. msg is a message explaining the failure (if any).


# 11.3 The Python Debugger and the `pdb` Module

The `pdb` module supports post-mortem debugging, inspection of stack frames, breakpoints, single-stepping of source lines, and code evaluation.

There are several functions for invoking the debugger from a program or from the interactive Python shell.
run(statement [, globals [, locals]])
