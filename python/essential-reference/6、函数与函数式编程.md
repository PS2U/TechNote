# 6.1 Functions

Fuctions are defined with the `def` statement:

```python
def add(x, y):
    return x + y
```

You can attach default arguments to function parameters by assigning values in the function definition. 

```python
def split(line,delimiter=','):
    statements
```

Default parameter values are always set to the objects that were supplied as values when the function was defined. 

```python
a = 10
def foo(x=a):
    return x
a = 5 # Reassign 'a'.
foo() # returns 10 (default value not changed)
```

The use of mutable objects as default values may lead to unintended behavior:

```python
def foo(x, items=[]):
    items.append(x)
    return items
foo(1) # returns [1]
foo(2) # returns [1, 2]
foo(3) # returns [1, 2, 3]
```

A function can accept a variable number of parameters if an asterisk (`*`) is added to the
last parameter name:

```python
def fprintf(file, fmt, *args):
	file.write(fmt % args)

# Use fprintf. args gets (42,"hello world", 3.45)
fprintf(out,"%d %s %f", 42, "hello world", 3.45)
```

In this case, all the remaining arguments are placed into the `args` variable as a tuple. To pass a tuple args to a function as if they were parameters, the `*args` syntax can be used in a function call as follows:

```python
def printf(fmt, *args):
    # Call another function and pass along args
    fprintf(sys.stdout, fmt, *args)
```

Function arguments can also be supplied by explicitly **naming each parameter and specifying a value**. These are known as keyword arguments. With keyword argument, the order of parameters does NOT matter.

```python
def foo(w,x,y,z):
    statements
# Keyword argument invocation
foo(x=3, y=22, w='hello', z=[1,2])
```

**Positional arguments and keyword arguments can appear in the same function call**, provided that all the positional arguments appear first, values are provided for all nonoptional arguments, and no argument value is defined more than once.

```python
foo('hello', 3, z=[1,2], y=22)
foo(3, 22, w='hello', z=[1,2]) # TypeError. Multiple values for w
```

If the last argument of a function definition begins with **, all the additional keyword
arguments are placed in a dictionary and passed to the function.

```python
def make_table(data, **parms):
    # Get configuration parameters from parms (a dict)
    fgcolor = parms.pop("fgcolor","black")
    bgcolor = parms.pop("bgcolor","white")
    width = parms.pop("width",None)
...
    # No more options
    if parms:
        raise TypeError("Unsupported configuration options %s" % list(parms))

make_table(items, fgcolor="black", bgcolor="white", border=1, borderstyle="grooved", cellpadding=10, width=400)
```

You can combine extra keyword arguments with variable-length argument lists, as long as the ** parameter appears last:

```python
# Accept variable number of positional or keyword arguments
def spam(*args, **kwargs):
    # args is a tuple of positional args
    # kwargs is dictionary of keyword args
```


# 6.2 Parameter Passing and Return Values

if a mutable object (such as a list or dictionary) is passed to a function where it’s then modified, those changes will be reflected in the original object.

```python
a = [1, 2, 3, 4, 5]
def square(items):
    for i,x in enumerate(items):
        items[i] = x * x # Modify items in-place

square(a) # Changes a to [1, 4, 9, 16, 25]
```

The return statement returns a value from a function. If no value is specified or you omit the return statement, the None object is returned.To return multiple values, place them in a tuple:

```python
def factor(a):
    d = 2
    while (d <= (a / 2)):
        if ((a / d) * d == a):
            return ((a / d), d)
        d = d + 1
    return (a, 1)

x, y = factor(1243)
(x, y) = factor(1243)
```

# 6.3 Scoping Rules

When resolving names, the interpreter searches:

1. local namespace
2. global namespace
3. built-in namespace
4. `NameError`

One peculiarity of namespaces is the manipulation of global variables within a function.

```python
a = 42
def foo():
    a = 13
foo()
# a is still 42
```

To alter this behavior, use the global statement.

```python
a = 42
b = 37
def foo():
    global a # 'a' is in global namespace
    a = 13
    b = 0
foo()
# a is now 13. b is still 37.
```

Although names in enclosing scopes are accessible, Python 2 only allows variables to be reassigned in the innermost scope (local
variables) and the global namespace (using global).Therefore, an inner function can’t reassign the value of a local variable defined in an outer function. 

```python
def countdown(start):
    n = start
    def display():
        print('T-minus %d' % n)
    def decrement():
        n -= 1 # Fails in Python 2
    while n > 0:
        display()
        decrement()
```

In Python 2, you can work around this by placing values you want to change in a list or dictionary. In Python 3, you can declare n as `nonlocal` as follows:

```python
def countdown(start):
    n = start
    def display():
        print('T-minus %d' % n)
    def decrement():
        nonlocal n # Bind to outer n (Python 3 only)
        n -= 1
    while n > 0:
        display()
        decrement()
```

If a local variable is used before it’s assigned a value, an `UnboundLocalError` exception is raised. 

```python
i = 0
def foo():
    i = i + 1 # Results in UnboundLocalError exception
    print(i)
```


# 6.4 Functions as Objects and Closures

Functions are first-class objects in Python.This means that they can be passed as arguments to other functions, placed in data structures, and returned by a function as a result.

When a function is handled as data, it implicitly carries information related to the surrounding environment where the function was defined.This affects how free variables in the function are bound. 

```python
# foo.py
x = 42
def callf(func):
    return func()
```

Now, observe the behavior of this example:

```python
import foo
x = 37
def helloworld():
    return "Hello World. x is %d" % x

foo.callf(helloworld) # Pass a function as an argument
# 'Hello World. x is 37'
```
  
When the statements that make up a function are packaged together with the environment in which they execute, the resulting object is known as a `closure`. The behavior of the previous example is explained by the fact that all functions have a `__globals__` attribute that points to the global namespace in which the function was defined.This always corresponds to the enclosing module in which a function was defined.

```python
helloworld.__globals__
# {'__builtins__': <module '__builtin__' (built-in)>, 'helloworld': <function helloworld at 0x7bb30>, 'x': 37, '__name__': '__main__', '__doc__': None 'foo': <module 'foo' from 'foo.py'>}
```


# 6.5 Decorators

A decorator is a function whose primary purpose is to wrap another function or class. The primary purpose of this wrapping is to transparently alter or enhance the behavior of the object being wrapped.

```python
@trace
def square(x):
    return x*x
```

The preceding code is shorthand for the following:

```python
def square(x):
    return x*x
square = trace(square)
```

```python
enable_tracing = True
if enable_tracing:
    debug_log = open("debug.log","w")

def trace(func):
    if enable_tracing:
        def callf(*args,**kwargs):
            debug_log.write("Calling %s: %s, %s\n" %
                        (func.__name__, args, kwargs))
            r = func(*args,**kwargs)
            debug_log.write("%s returned %s\n" % (func.__name, r))
            return r
        return callf
    else:
        return func
```

In this code, trace() creates a wrapper function that writes some debugging output and then calls the original function object.

When decorators are used, they must appear on their own line immediately prior to a function or class definition. More than one decorator can also be applied.

A decorator can also accept arguments.


# 6.6 Generators and `yield`

If a function uses the yield keyword, it defines an object known as a generator. A generator is a function that produces a sequence of values for use in iteration.

```python
def countdown(n):
    print("Counting down from %d" % n)
    while n > 0:
        yield n
        n -= 1
    return

c = countdown(10) # none of its code starts executing, instead, a generator object is returned. 

# The generator object, in turn, executes the function whenever next() is called.
c.next() # Counting down from 10
c.next() # 9
```

When next() is invoked, the generator function executes statements until it reaches a yield statement.The yield statement produces a result at which point execution of the function stops until next() is invoked again. Execution then resumes with the statement following yield.

You normally don’t call next() directly on a generator but use it with the for statement, sum(), or some other operation that consumes a sequence. 

```python
for n in countdown(10):
    statements
a = sum(countdown(10))
```

A generator function signals completion by returning or raising `StopIteration`, at which point iteration stops. It is never legal for a generator to return a value other than `None` upon completion.

A subtle problem with generators concerns the case where a generator function is only partially consumed.

```python
for n in countdown(10):
    if n == 2: break
    statements
```

To handle this case, generator objects have a method `close()` that is used to signal a shutdown.When a generator is no longer used or deleted, `close()` is called.

Inside the generator function, `close()` is signaled by a `GeneratorExit` exception occurring on the `yield` statement.You can optionally catch this exception to perform cleanup actions.

```python
def countdown(n):
    print("Counting down from %d" % n)
    try:
        while n > 0:
            yield n
            n = n - 1
    except GeneratorExit:
        print("Only made it to %d" % n)
```

Although it is possible to catch `GeneratorExit`, it is illegal for a generator function to handle the exception and produce another output value using `yield`.


# 6.7 Coroutines and `yield` Expressions
