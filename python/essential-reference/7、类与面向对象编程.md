Classes are the mechanism used to create new kinds of objects.

# 7.1 The `class` Statement

A `class` defines a set of attributes that associated with, and shared by, a collection of objects known as `instances`. A class is most commonly a collection of functions (known as `methods`), variables (which are known as class `variables`), and computed attributes (which are known as `properties`).

A class is defined using the `class` statement.

```python
class Account(object):
    num_accounts = 0
    def __init__(self,name,balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1
    def __del__(self):
        Account.num_accounts -= 1
    def deposit(self,amt):
        self.balance = self.balance + amt
    def withdraw(self,amt):
        self.balance = self.balance - amt
    def inquiry(self):
        return self.balance
```

The values created during the execution of the class body are placed into a class object that serves as a namespace much like a module. 

```python
Account.num_accounts
Account.__init__
Account.__del__
Account.deposit
Account.withdraw
Account.inquiry
```

A `class` statement doesn't create any instances of class. Rather, a class merely sets up the attributes that will be common to all the instances that will be created later.

The functions defined inside a calss are known as `instance methods`. By Convention, the first argument is `self`, although any legal identifier name can be used.

Class variables such as `num_accounts` are values that are shared amongo all instances of a class.


# 7.2 Class Instances

Instances of a class are created by calling a class object as a function.This creates a new instance that is then passed to the `__init__()` method of the class.

```python
# Create a few accounts
a = Account("Guido", 1000.00) # Invokes Account.__init__(a,"Guido",1000.00)

a.deposit(100.00) # Calls Account.deposit(a,100.00)
b.withdraw(50.00) # Calls Account.withdraw(b,50.00)
name = a.name # Get account name
```

the dot(.) operator is responsible for attribute binding.


# 7.3 Scoping Rules

Although classes define a namespace, classes do not create a scope for names used inside the bodies of methods.

```python
class Foo(object):
    def bar(self):
        print("bar!")
    def spam(self):
        bar(self) # Incorrect! 'bar' generates a NameError
        self.bar() # This works
        Foo.bar(self) # This also works
```

The explicit use of `self` is required because Python does not provide a means to explicitly declare variables.


# 7.4 Inheritance

Inheritance is a mechanism for creating a new class that specializes or modifies the behavior of an existing class.

`object` is the root of all Python objects and provides the default implementation of some common methods such as `__str__()`.

```python
import random
class EvilAccount(Account):
    def inquiry(self):
        if random.randint(0,4) == 1:
            return self.balance * 1.10 # Note: Patent pending idea
        else:
            return self.balance

c = EvilAccount("George", 1000.00)
c.deposit(10.0) # Calls Account.deposit(c,10.0)
available = c.inquiry() # Calls EvilAccount.inquiry(c)
```

A subclass can add new attributes to the instances by defining its own version of `__init()__`. If you don’t know whether the
base class defines `__init__()`, it is always safe to call it without any arguments because there is always a default implementation that simply does nothing.

Occasionally, a derived class will reimplement a method but also want to call the original implementation.To do this, a method can explicitly call the original method in the base class, passing the instance `self` as the first parameter as shown here:

```python
class MoreEvilAccount(EvilAccount):
    def deposit(self,amount):
        self.withdraw(5.00) # Subtract the "convenience" fee
        EvilAccount.deposit(self,amount) # Now, make deposit
```

An alternative solution is to use the `super()` function as follows:

```python
class MoreEvilAccount(EvilAccount):
    def deposit(self,amount):
        self.withdraw(5.00) # Subtract convenience fee
        super(MoreEvilAccount,self).deposit(amount) # Now, make deposit

        # In Python 3, simplified statement
        # super().deposit(amount) 
```

`super(cls, instance)` returns a special object that lets you perform attribute lookups on the base classes.

**Python supports multiple inheritance.** To find attributes with multiple inheritance, all base classes are ordered in a list from the “most specialized” class to the “least specialized” class.Then, when searching for an attribute, this list is searched in order until the first definition of the attribute is found. For any given class, the ordering of base classes can be viewed by printing
its `__mro__` attribute.

A subtle aspect of this algorithm is that certain class hierarchies will be rejected by Python with a `TypeError`. 

```python
class X(object): pass
class Y(X): pass
class Z(X,Y): pass # TypeError.
# Can't create consistent method resolution order__
```

A mixin class typically defines a set of methods that are meant to be “mixed in” to other classes in order to add extra functionality (almost like a macro).


# 7.5 Polymorphisom Dynamic Binding and Duck Typing

`Dynamic binding` (also sometimes referred to as `polymorphism` when used in the context of inheritance) is the capability to use an instance without regard for its type. It is handled entirely through the attribute lookup process described for inheritance in the preceding section.Whenever an attribute is accessed as obj.attr, attr is located by searching within the instance itself, the instance’s class definition, and then base classes, in that order.The first match found is returned.

A critical aspect of this binding process is that it is independent of what kind of object obj is.Thus, if you make a lookup such as `obj.name`, it will work on any `obj` that happens to have a name attribute.This behavior is sometimes referred to as `duck typing` in reference to the adage “if it looks like, quacks like, and walks like a duck, then it’s a duck.”


# 7.6 Static Methods and Class Methods

In a class definition, all functions are assumed to operate on an instance, which is always passed as the first parameter `self`.

A `static method` is an ordinary function that just happens to live in the namespace defined by a class. It does not operate on any kind of instance.

```python
class Foo(object):
    @staticmethod
    def add(x,y):
        return x + y
```

To call a static method, you just prefix it by the class name.You do not pass it any additional information.

```python
x = Foo.add(3,4) # x = 7
```

`Class methods` are methods that operate on the class itself as an object. A class method is different than an instance method in that the class is passed as the first argument which is named `cls` by convention.

```python
class Times(object):
    factor = 1
    @classmethod
    def mul(cls,x):
        return cls.factor*x

class TwoTimes(Times):
    factor = 2

x = TwoTimes.mul(4) # Calls Times.mul(TwoTimes, 4) -> 8
```

One caution about static and class methods is that Python does not manage these methods in a separate namespace than the instance methods. As a result, they can be invoked on an instance. 

```python
a = Date(1967,4,9)
b = d.now() # Calls Date.now(Date)
```


# 7.7 Properties

A property is a special kind of attribute that computes its value when accessed. 

```python
class Circle(object):
    def __init__(self,radius):
        self.radius = radius
    # Some additional properties of Circles
    @property
    def area(self):
        return math.pi*self.radius**2
    @property
    def perimeter(self):
        return 2*math.pi*self.radius
```

```
>>> c = Circle(4.0)
>>> c.radius
4.0
>>> c.area
50.26548245743669
>>> c.perimeter
25.132741228718345
>>> c.area = 2
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AttributeError: can't set attribute
>>>
```

The `@property` decorator makes it possible for the method that follows to be accessed as a simple attribute, without the extra () that you would normally have to add to call the method.

Python programmers don’t often realize that **methods themselves are implicitly handled as a kind of property**.

```python
class Foo(object):
    def __init__(self,name):
        self.name = name
    def spam(self,x):
        print("%s, %s" % (self.name, x)
```

When a user creates an instance such as `f = Foo("Guido")` and then accesses `f.spam`, the original function object `spam` is not returned. Instead, you get something known as a `bound method`, which is an object that represents the method call that will execute when the `()` operator is invoked on it. A bound method is like a partially evaluated function where the self parameter has already been filled in, but the additional arguments still need to be supplied by you when you call it using ().

Properties can also intercept operations to set and delete an attribute.

```python
class Foo(object):
    def __init__(self,name):
        self._ _name = name
    @property
    def name(self):
        return self.__name
    @name.setter
    def name(self,value):
        if not isinstance(value,str):
            raise TypeError("Must be a string!")
        self.__name = value
    @name.deleter
    def name(self):
        raise TypeError("Can't delete name")

f = Foo("Guido")
n = f.name # calls f.name() - get function
f.name = "Monty" # calls setter name(f,"Monty")
f.name = 45 # calls setter name(f,45) -> TypeError
del f.name # Calls deleter name(f) -> TypeError
```


# 7.8 Descriptors

A descriptor is simply an object that represents the value of an attribute. By implementing one or more of the special methods `__get__()`, `__set__()`, and `__delete__()`, it can hook into the attribute access mechanism and can customize those operations.

```python
class TypedProperty(object):
    def __init__(self,name,type,default=None):
        self.name = "_" + name
        self.type = type
        self.default = default if default else type()
    def __get__(self,instance,cls):
        return getattr(instance,self.name,self.default)
    def __set__(self,instance,value):
        if not isinstance(value,self.type):
            raise TypeError("Must be a %s" % self.type)
        setattr(instance,self.name,value)
    def __delete__(self,instance):
        raise AttributeError("Can't delete attribute")

class Foo(object):
    name = TypedProperty("name",str)
    num = TypedProperty("num",int,42)

f = Foo()
a = f.name # Implicitly calls Foo.name.__get__(f,Foo)
f.name = "Guido" # Calls Foo.name.__set__(f,"Guido")
del f.name # Calls Foo.name.__delete__(f)
```

Descriptors can only be instantiated at the class level. It is not legal to create descriptors on a per-instance basis by creating descriptor objects inside `__init__()` and other methods. Also, the attribute name used by the class to hold a descriptor takes precedence over attributes stored on instances.


# 7.9 Data Encapsulation and Private Attribues

By default, all attributes and methods of a class are “public”. To fix this problem, all names in a class that start with a double underscore, such as `__Foo`, are automatically mangled to form a new name of the form `_Classname__Foo`.

```python
class A(object):
    def __init__(self):
        self.__X = 3 # Mangled to self._A__X
    def __spam(self): # Mangled to _A__spam()
        pass
    def bar(self):
        self.__spam() # Only calls A.__spam()

class B(A):
    def __init__(self):
        A.__init__(self)
        self.__X = 37 # Mangled to self._B__X
    def __spam(self): # Mangled to _B__spam()
        pass
```

Although this scheme provides the illusion of data hiding, there’s no strict mechanism in place to actually prevent access to the “private” attributes of a class. A class can make these attributes less visible by redefining the `__dir__()` method, which supplies the list of names returned by the `dir()` function that’s used to inspect objects.

The mangling process actually only occurs once at the time a class is defined. Also, be aware that name mangling does not occur in functions such as `getattr()`, `hasattr()`, `setattr()`, or `delattr()` where the attribute name is specified as a string. For these functions, you need to explicitly use the mangled name such as `_Classname__name` to access the attribute.

It is recommended that private attributes be used when defining mutable attributes via properties.

Giving a method a private name is a technique that a superclass can use to prevent a derived class from redefining and changing the implementation of a method.

Finally, don’t confuse the naming of private class attributes with the naming of “private” definitions in a module. A common mistake is to define a class where a single leading underscore is used on attribute names in an effort to hide their values (e.g., `_name`). In modules, this naming convention prevents names from being exported by the `from module import * statement`. However, in classes, this naming convention does not hide the attribute nor does it prevent name clashes that arise if someone inherits from the class and defines a new attribute or method with the same name.


# 7.10 Object Memory Management

The creation of an instance is carried out in two steps using the special method `__new__()`, which creates a new instance, and `__init__()`, which initializes it. For example, the operation `c = Circle(4.0)` performs these steps:

```python
c = Circle.__new__(Circle, 4.0)
if isinstance(c,Circle):
Circle.__init__(c,4.0)
```

The `__new__()` method of a class is something that is rarely defined by user code. If it is defined, it is typically written with the prototype `__new__(cls, *args, **kwargs)` where args and kwargs are the same arguments that will be passed to `__init__()`. `__new__()` is always a class method that receives the class object as the first parameter.

When the instance is about to be destroyed, the interpreter first looks for a `__del__()` method associated with the object and calls it. There’s no guarantee that this method will be called when the interpreter exits.

Occasionally, a program will use the `del` statement to delete a reference to an object. If this causes the reference count of the object to reach zero, the `__del__()` method is called. However, in general, the `del` statement doesn’t directly call `__del__()`.

A weak reference is a way of creating a reference to an object without increasing its reference count.

```python
import weakref
class AccountObserver(object):
    def __init__(self, theaccount):
        self.accountref = weakref.ref(theaccount) # Create a weakref
        theaccount.register(self)
    def __del__(self):
        acc = self.accountref() # Get account
        if acc: # Unregister if still exists
            acc.unregister(self)
    def update(self):
        print("Balance is %0.2f" % self.accountref().balance)
    def close(self):
        print("Account no longer in use")

# Example setup
a = Account('Dave',1000.00)
a_ob = AccountObserver(a)
```


# 7.11 Object Representation and Attribute Bingding

Internally, instances are implemented using a dictionary that’s accessible as the instance’s `__dict__` attribute.This dictionary contains the data that’s unique to each instance.

```
>>> a = Account('Guido', 1100.0)
>>> a.__dict__
{'balance': 1100.0, 'name': 'Guido'}
```

New attributes can be added to an instance at any time, like this:

```python
a.number = 123456 # Add attribute 'number' to a.__dict__ 
```

Modifications to an instance are always reflected in the local `__dict__` attribute. Likewise, if you make modifications to `__dict__` directly, those modifications are reflected in the attributes.

Instances are linked back to their class by a special attribute `__class__`.The class itself is also just a thin layer over a dictionary which can be found in its own `__dict__` attribute.The class dictionary is where you find the methods.

Finally, classes are linked to their base classes in a special attribute `__bases__`, which is a tuple of the base classes.This underlying structure is the basis for all of the operations that `get`, `set`, and `delete` the attributes of objects.

Whenever an attribute is set using `obj.name = value`, the special method `obj.__setattr__("name", value)` is invoked. If an attribute is deleted using `del obj.name`, the special method `obj.__delattr__("name")` is invoked.

For attribute lookup such as `obj.name`, the special method `obj.__getattrribute__("name")` is invoked.This method carries out the search process for finding the attribute, which normally includes checking for properties, looking in the local `__dict__` attribute, checking the class dictionary, and searching the base classes. If this search process fails, a final attempt to find the attribute is made by trying to invoke the `__getattr__()` method of the class (if defined). If this fails, an `AttributeError` exception is raised.


# 7.12 `__slots__`

A class can restrict the set of legal instance attribute names by defining a special variable called `__slots__`. 

```python
class Account(object):
    __slots__ = ('name','balance')
```

When `__slots__` is defined, the attribute names that can be assigned on instances are restricted to the names specified. Otherwise, an AttributeError exception is raised.

Instances of a class that uses `__slots__` no longer use a dictionary for storing instance data. Instead, a much more compact data structure based on an array is used.

Be aware that the use of `__slots__` has a tricky interaction with inheritance. If a class inherits from a base class that uses `__slots__`, it also needs to define `__slots__` for storing its own attributes (even if it doesn’t add any) to take advantage of the benefits `__slots__` provides. If you forget this, the derived class will run slower and use even more memory than what would have been used if `__slots__` had not been used on any of the classes!

Finally, the presence of `__slots__` has no effect on the invocation of methods such as `__getattribute__()`, `__getattr__()`, and `__setattr__()` should they be redefined in a class.


# 7.13 Operator Overloading

