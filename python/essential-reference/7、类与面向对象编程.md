Classes are the mechanism used to create new kinds of objects.

# 7.1 The `class` Statement

A `class` defines a set of attributes that associated with, and shared by, a collection of objects known as `instances`. A class is most commonly a collection of functions (known as `methods`), variables (which are known as class `variables`), and computed attributes (which are known as `properties`).

A class is defined using the `class` statement.

```python
class Account(object):
    num_accounts = 0
    def __init__(self,name,balance):
        self.name = name
        self.balance = balance
        Account.num_accounts += 1
    def __del__(self):
        Account.num_accounts -= 1
    def deposit(self,amt):
        self.balance = self.balance + amt
    def withdraw(self,amt):
        self.balance = self.balance - amt
    def inquiry(self):
        return self.balance
```

The values created during the execution of the class body are placed into a class object that serves as a namespace much like a module. 

```python
Account.num_accounts
Account.__init__
Account.__del__
Account.deposit
Account.withdraw
Account.inquiry
```

A `class` statement doesn't create any instances of class. Rather, a class merely sets up the attributes that will be common to all the instances that will be created later.

The functions defined inside a calss are known as `instance methods`. By Convention, the first argument is `self`, although any legal identifier name can be used.

Class variables such as `num_accounts` are values that are shared amongo all instances of a class.


# 7.2 Class Instances

Instances of a class are created by calling a class object as a function.This creates a new instance that is then passed to the `__init__()` method of the class.

```python
# Create a few accounts
a = Account("Guido", 1000.00) # Invokes Account.__init__(a,"Guido",1000.00)

a.deposit(100.00) # Calls Account.deposit(a,100.00)
b.withdraw(50.00) # Calls Account.withdraw(b,50.00)
name = a.name # Get account name
```

the dot(.) operator is responsible for attribute binding.


# 7.3 Scoping Rules

Although classes define a namespace, classes do not create a scope for names used inside the bodies of methods.

```python
class Foo(object):
    def bar(self):
        print("bar!")
    def spam(self):
        bar(self) # Incorrect! 'bar' generates a NameError
        self.bar() # This works
        Foo.bar(self) # This also works
```

The explicit use of `self` is required because Python does not provide a means to explicitly declare variables.


# 7.4 Inheritance

Inheritance is a mechanism for creating a new class that specializes or modifies the behavior of an existing class.

`object` is the root of all Python objects and provides the default implementation of some common methods such as `__str__()`.

```python
import random
class EvilAccount(Account):
    def inquiry(self):
        if random.randint(0,4) == 1:
            return self.balance * 1.10 # Note: Patent pending idea
        else:
            return self.balance

c = EvilAccount("George", 1000.00)
c.deposit(10.0) # Calls Account.deposit(c,10.0)
available = c.inquiry() # Calls EvilAccount.inquiry(c)
```

A subclass can add new attributes to the instances by defining its own version of `__init()__`. If you don’t know whether the
base class defines `__init__()`, it is always safe to call it without any arguments because there is always a default implementation that simply does nothing.

Occasionally, a derived class will reimplement a method but also want to call the original implementation.To do this, a method can explicitly call the original method in the base class, passing the instance `self` as the first parameter as shown here:

```python
class MoreEvilAccount(EvilAccount):
    def deposit(self,amount):
        self.withdraw(5.00) # Subtract the "convenience" fee
        EvilAccount.deposit(self,amount) # Now, make deposit
```

An alternative solution is to use the `super()` function as follows:

```python
class MoreEvilAccount(EvilAccount):
    def deposit(self,amount):
        self.withdraw(5.00) # Subtract convenience fee
        super(MoreEvilAccount,self).deposit(amount) # Now, make deposit

        # In Python 3, simplified statement
        # super().deposit(amount) 
```

`super(cls, instance)` returns a special object that lets you perform attribute lookups on the base classes.

**Python supports multiple inheritance.** To find attributes with multiple inheritance, all base classes are ordered in a list from the “most specialized” class to the “least specialized” class.Then, when searching for an attribute, this list is searched in order until the first definition of the attribute is found. For any given class, the ordering of base classes can be viewed by printing
its `__mro__` attribute.

A subtle aspect of this algorithm is that certain class hierarchies will be rejected by Python with a `TypeError`. 

```python
class X(object): pass
class Y(X): pass
class Z(X,Y): pass # TypeError.
# Can't create consistent method resolution order__
```

A mixin class typically defines a set of methods that are meant to be “mixed in” to other classes in order to add extra functionality (almost like a macro).


# 7.5 Polymorphisom Dynamic Binding and Duck Typing

`Dynamic binding` (also sometimes referred to as `polymorphism` when used in the context of inheritance) is the capability to use an instance without regard for its type. It is handled entirely through the attribute lookup process described for inheritance in the preceding section.Whenever an attribute is accessed as obj.attr, attr is located by searching within the instance itself, the instance’s class definition, and then base classes, in that order.The first match found is returned.

A critical aspect of this binding process is that it is independent of what kind of object obj is.Thus, if you make a lookup such as `obj.name`, it will work on any `obj` that happens to have a name attribute.This behavior is sometimes referred to as `duck typing` in reference to the adage “if it looks like, quacks like, and walks like a duck, then it’s a duck.”


# 7.6 Static Methods and Class Methods

In a class definition, all functions are assumed to operate on an instance, which is always passed as the first parameter `self`.

A `static method` is an ordinary function that just happens to live in the namespace defined by a class. It does not operate on any kind of instance.

```python
class Foo(object):
    @staticmethod
    def add(x,y):
        return x + y
```

To call a static method, you just prefix it by the class name.You do not pass it any additional information.

```python
x = Foo.add(3,4) # x = 7
```

`Class methods` are methods that operate on the class itself as an object. A class method is different than an instance method in that the class is passed as the first argument which is named `cls` by convention.

```python
class Times(object):
    factor = 1
    @classmethod
    def mul(cls,x):
        return cls.factor*x

class TwoTimes(Times):
    factor = 2

x = TwoTimes.mul(4) # Calls Times.mul(TwoTimes, 4) -> 8
```

One caution about static and class methods is that Python does not manage these methods in a separate namespace than the instance methods. As a result, they can be invoked on an instance. 

```python
a = Date(1967,4,9)
b = d.now() # Calls Date.now(Date)
```


# 7.7 Properties

A property is a special kind of attribute that computes its value when accessed. 

```python
class Circle(object):
    def __init__(self,radius):
        self.radius = radius
    # Some additional properties of Circles
    @property
    def area(self):
        return math.pi*self.radius**2
    @property
    def perimeter(self):
        return 2*math.pi*self.radius
```

```
>>> c = Circle(4.0)
>>> c.radius
4.0
>>> c.area
50.26548245743669
>>> c.perimeter
25.132741228718345
>>> c.area = 2
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AttributeError: can't set attribute
>>>
```

The `@property` decorator makes it possible for the method that follows to be accessed as a simple attribute, without the extra () that you would normally have to add to call the method.

