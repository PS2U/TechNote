简易 查询 —query-string search— 对于用命令行进行点对点（ad-hoc）查询是非常有用的。 然而，为了充分利用查询的强大功能，你应该使用 请求体 search API， 之所以称之为请求体查询(Full-Body Search)，因为大部分参数是通过 Http 请求体而非查询字符串来传递的。

请求体查询不仅可以处理自身的查询请求，还允许你对结果进行片段强调（高亮）、对所有或部分结果进行聚合分析，同时还可以给出 你是不是想找 的建议，这些建议可以引导使用者快速找到他想要的结果。

# 空查询

空查询将返回所有索引库（indices)中的所有文档：

```
GET /_search
{}
```

只用一个查询字符串，你就可以在一个、多个或者 `_all` 索引库（indices）和一个、多个或者所有types中查询：

```
GET /index_2014*/type1,type2/_search
{}
```

同时你可以使用 `from` 和 `size` 参数来分页：

```
GET /_search
{
  "from": 30,
  "size": 10
}
```

> **一个带请求体的 GET 请求？**
>
> 某些特定语言（特别是 JavaScript）的 HTTP 库是不允许 `GET` 请求带有请求体的。 
>
> 而事实是这个RFC文档 [RFC 7231](http://tools.ietf.org/html/rfc7231#page-24)— 一个专门负责处理 HTTP 语义和内容的文档 — 并没有规定一个带有请求体的 `GET` 请求应该如何处理！结果是，一些 HTTP 服务器允许这样子，而有一些 — 特别是一些用于缓存和代理的服务器 — 则不允许。
>
> 对于一个查询请求，Elasticsearch 的工程师偏向于使用 `GET` 方式，因为他们觉得它比 `POST` 能更好的描述信息检索（retrieving information）的行为。然而，因为带请求体的 `GET` 请求并不被广泛支持，所以 `search` API 同时支持 `POST` 请求：
>
> ```
> POST /_search
> {
>   "from": 30,
>   "size": 10
> }
> ```

# 查询表达式

查询表达式(Query DSL)是一种非常灵活又富有表现力的 查询语言。 Elasticsearch 使用它可以以简单的 JSON 接口来展现 Lucene 功能的绝大部分。

要使用这种查询表达式，只需将查询语句传递给 `query` 参数：

```
GET /_search
{
    "query": YOUR_QUERY_HERE
}
```

*空查询（empty search）* —`{}`— 在功能上等价于使用 `match_all` 查询， 正如其名字一样，匹配所有文档：

```
GET /_search
{
    "query": {
        "match_all": {}
    }
}
```

## 查询语句的结构

一个查询语句 的典型结构：

```
{
    QUERY_NAME: {
        ARGUMENT: VALUE,
        ARGUMENT: VALUE,...
    }
}
```

如果是针对某个字段，那么它的结构如下：

```
{
    QUERY_NAME: {
        FIELD_NAME: {
            ARGUMENT: VALUE,
            ARGUMENT: VALUE,...
        }
    }
}
```

举个例子，你可以使用 `match` 查询语句 来查询 `tweet` 字段中包含 `elasticsearch` 的 tweet：

```
{
    "match": {
        "tweet": "elasticsearch"
    }
}
```

## 合并查询语句

*查询语句(Query clauses)* 就像一些简单的组合块 ，这些组合块可以彼此之间合并组成更复杂的查询。这些语句可以是如下形式：

- *叶子语句（Leaf clauses）* (就像 `match` 语句) 被用于将查询字符串和一个字段（或者多个字段）对比。
- *复合(Compound)* 语句 主要用于 合并其它查询语句。 比如，一个 `bool` 语句 允许在你需要的时候组合其它语句，无论是 `must` 匹配、 `must_not` 匹配还是 `should` 匹配，同时它可以包含不评分的过滤器（filters）：

```
{
    "bool": {
        "must":     { "match": { "tweet": "elasticsearch" }},
        "must_not": { "match": { "name":  "mary" }},
        "should":   { "match": { "tweet": "full text" }},
        "filter":   { "range": { "age" : { "gt" : 30 }} }
    }
}
```

# 查询与过滤

Elasticsearch 使用的查询语言（DSL） 拥有一套查询组件，这些组件可以以无限组合的方式进行搭配。这套组件可以在以下两种情况下使用：过滤情况（filtering context）和查询情况（query context）。

- 当使用于 *过滤情况* 时，查询被设置成一个“不评分”或者“过滤”查询。即，这个查询只是简单的问一个问题：“这篇文档是否匹配？”。回答也是非常的简单，yes 或者 no ，二者必居其一。
- 当使用于 *查询情况* 时，查询就变成了一个“评分”的查询。和不评分的查询类似，也要去判断这个文档是否匹配，同时它还需要判断这个文档匹配的有 _多好_（匹配程度如何）。

## 性能差异

过滤查询（Filtering queries）只是简单的检查包含或者排除，这就使得计算起来非常快。考虑到至少有一个过滤查询（filtering query）的结果是 “稀少的”（很少匹配的文档），并且经常使用不评分查询（non-scoring queries），结果会被缓存到内存中以便快速读取，所以有各种各样的手段来优化查询结果。

相反，评分查询（scoring queries）不仅仅要找出 匹配的文档，还要计算每个匹配文档的相关性，计算相关性使得它们比不评分查询费力的多。同时，查询结果并不缓存。

过滤（filtering）的目标是减少那些需要通过评分查询（scoring queries）进行检查的文档。

## 如何选择查询与过滤

通常的规则是，使用 查询（query）语句来进行 *全文* 搜索或者其它任何需要影响 *相关性得分* 的搜索。除此以外的情况都使用过滤（filters)。

