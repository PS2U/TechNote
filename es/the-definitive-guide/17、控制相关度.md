Lucene（或 Elasticsearch）使用 [*布尔模型（Boolean model）*](http://en.wikipedia.org/wiki/Standard_Boolean_model) 查找匹配文档， 并用一个名为 [*实用评分函数（practical scoring function）*](http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/practical-scoring-function.html) 的公式来计算相关度。这个公式借鉴了 [*词频/逆向文档频率（term frequency/inverse document frequency）*](http://en.wikipedia.org/wiki/Tfidf) 和 [*向量空间模型（vector space model）*](http://en.wikipedia.org/wiki/Vector_space_model)，同时也加入了一些现代的新特性，如协调因子（coordination factor），字段长度归一化（field length normalization），以及词或查询语句权重提升。

# 相关度评分背后的理论

## 布尔模型

*布尔模型（Boolean Model）* 只是在查询中使用 `AND` 、 `OR` 和 `NOT` （与、或和非）这样的条件来查找匹配的文档，以下查询：

```
full AND text AND search AND (elasticsearch OR lucene)
```

## 词频/逆向文档频率（TF/IDF）

词的权重由三个因素决定：

- 词频。词在文档中出现的频度是多少？ 频度越高，权重 *越高* 。
- 逆向文档频率。词在集合所有文档里出现的频率是多少？频次越高，权重 *越低* 。 
- 字段长度归一值。字段的长度是多少？ 字段越短，字段的权重 *越高* 。

当用 `explain` 查看一个简单的 `term` 查询时，可以发现与计算相关度评分的因子。

## 向量空间模型

*向量空间模型（vector space model）* 提供一种比较多词查询的方式，单个评分代表文档与查询的匹配程度，为了做到这点，这个模型将文档和查询都以 *向量（vectors）* 的形式表示：

向量实际上就是包含多个数的一维数组，例如：

```
[1,2,5,22,3,8]
```

在向量空间模型里， 向量空间模型里的每个数字都代表一个词的 *权重* ，与 [词频/逆向文档频率（term frequency/inverse document frequency）](http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/scoring-theory.html#tfidf) 计算方式类似。

向量之间是可以比较的，只要测量查询向量和文档向量之间的角度就可以得到每个文档的相关度。



# Lucene 的实用评分函数

对于多词查询， Lucene 使用 [布尔模型（Boolean model）](http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/scoring-theory.html#boolean-model) 、 [TF/IDF](http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/scoring-theory.html#tfidf) 以及 [向量空间模型（vector space model）](http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/scoring-theory.html#vector-space-model) ，然后将它们组合到单个高效的包里以收集匹配文档并进行评分计算。

一个多词查询

```
GET /my_index/doc/_search
{
  "query": {
    "match": {
      "text": "quick fox"
    }
  }
}
```

会在内部被重写为：

```
GET /my_index/doc/_search
{
  "query": {
    "bool": {
      "should": [
        {"term": { "text": "quick" }},
        {"term": { "text": "fox"   }}
      ]
    }
  }
}
```

只要一个文档与查询匹配，Lucene 就会为查询计算评分，然后合并每个匹配词的评分结果。这里使用的评分计算公式叫做 *实用评分函数（practical scoring function）* 。

## 查询归一因子

*查询归一因子* （ `queryNorm` ）试图将查询 *归一化* ， 这样就能将两个不同的查询结果相比较。

## 查询协调

*协调因子* （ `coord` ） 可以为那些查询词包含度高的文档提供奖励，文档里出现的查询词越多，它越有机会成为好的匹配结果。

## 索引时字段层权重提升

让字段 *权重提升* 就是让某个字段比其他字段更重要。 当然在索引时也能做到如此。实际上，权重的提升会被应用到字段的每个词，而不是字段本身。

不建议在建立索引时对字段提升权重，有以下原因：

- 将提升值与字段长度归一值合在单个字节中存储会丢失字段长度归一值的精度，这样会导致 Elasticsearch 不知如何区分包含三个词的字段和包含五个词的字段。
- 要想改变索引时的提升值，就必须重新为所有文档建立索引，与此不同的是，查询时的提升值可以随着每次查询的不同而更改。
- 如果一个索引时权重提升的字段有多个值，提升值会按照每个值来自乘，这会导致该字段的权重急剧上升。

查询时赋予权重是更为简单、清楚、灵活的选择。

# 查询时赋予权重

搜索时使用 `boost` 参数让一个查询语句比其他语句更重要。 例如：

```
GET /_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "title": {
              "query": "quick brown fox",
              "boost": 2 
            }
          }
        },
        {
          "match": { 
            "content": "quick brown fox"
          }
        }
      ]
    }
  }
}
```

## 提升索引权重

当在多个索引中搜索时， 可以使用参数 `indices_boost` 来提升整个索引的权重，在下面例子中，当要为最近索引的文档分配更高权重时，可以这么做：

```
GET /docs_2014_*/_search 
{
  "indices_boost": { 
    "docs_2014_10": 3,
    "docs_2014_09": 2
  },
  "query": {
    "match": {
      "text": "quick brown fox"
    }
  }
}
```

## t.getBoost()

这些提升值在 Lucene 的 [实用评分函数](http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/practical-scoring-function.html) 中可以通过 `t.getBoost()` 获得。 权重提升不会被应用于它在查询表达式中出现的层，而是会被合并下转至每个词中。 `t.getBoost()` 始终返回当前词的权重或当前分析链上查询的权重。



# 使用查询结构修改相关度

设想下面这个查询：

```
quick OR brown OR red OR fox
```

可以将所有词都放在 `bool` 查询的同一层中：

```
GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "term": { "text": "quick" }},
        { "term": { "text": "brown" }},
        { "term": { "text": "red"   }},
        { "term": { "text": "fox"   }}
      ]
    }
  }
}
```

但是如果想做以下查询：

```
quick OR (brown OR red) OR fox
```

```
GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "term": { "text": "quick" }},
        { "term": { "text": "fox"   }},
        {
          "bool": {
            "should": [
              { "term": { "text": "brown" }},
              { "term": { "text": "red"   }}
            ]
          }
        }
      ]
    }
  }
}
```



# Not Quite Not

在互联网上搜索 “Apple”，返回的结果很可能是一个公司、水果和各种食谱。 我们可以在 `bool` 查询中用 `must_not` 语句来排除像 `pie` 、 `tart` 、 `crumble` 和 `tree` 这样的词，从而将查询结果的范围缩小至只返回与 “Apple” （苹果）公司相关的结果。

但谁又敢保证在排除 `tree` 或 `crumble` 这种词后，不会错失一个与苹果公司特别相关的文档呢？有时， `must_not` 条件会过于严格。

[`boosting` 查询](https://www.elastic.co/guide/en/elasticsearch/reference/master/query-dsl-boosting-query.html) 仍然允许我们将关于水果或甜点的结果包括到结果中，但是使它们降级——即降低它们原来可能应有的排名：

```
GET /_search
{
  "query": {
    "boosting": {
      "positive": {
        "match": {
          "text": "apple"
        }
      },
      "negative": {
        "match": {
          "text": "pie tart fruit crumble tree"
        }
      },
      "negative_boost": 0.5
    }
  }
}
```



# 忽略 TF/IDF

有时候我们根本不关心 TF/IDF ， 只想知道一个词是否在某个字段中出现过。

在 [`constant_score`](https://www.elastic.co/guide/en/elasticsearch/reference/master/query-dsl-constant-score-query.html) 查询中，它可以包含查询或过滤，为任意一个匹配的文档指定评分 `1` ，忽略 TF/IDF 信息：

```
GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "constant_score": {
          "query": { "match": { "description": "wifi" }}
        }},
        { "constant_score": {
          "query": { "match": { "description": "garden" }}
        }},
        { "constant_score": {
          "boost":   2 
          "query": { "match": { "description": "pool" }}
        }}
      ]
    }
  }
}
```

最终的评分并不是所有匹配语句的简单求和， [协调因子（coordination factor）](http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/practical-scoring-function.html#coord) 和 [查询归一化因子（query normalization factor）](http://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/practical-scoring-function.html#query-norm) 仍然会被考虑在内。

