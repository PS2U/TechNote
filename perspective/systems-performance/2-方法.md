面对一个性能不佳且复杂的系统环境，第一个挑战就是知道从什么地方开始分析，收集什么样的数据，以及如何分析这些数据。

# 2.1 术语

关于性能的一些关键术语：

- IOPS：每秒的 IO 操作次数
- 吞吐量：数据传输的速度。某些情况下，吞吐量是指操作的速度（每秒的操作数）
- 响应时间：一次操作完成的时间
- 延时：描述操作里用来等待的时间
- 使用率：对于服务请求的资源，使用率描述在给定时间区间内，资源的繁忙程度
- 饱和度：某一资源无法满足服务的排队工作量
- 瓶颈
- 工作负载：系统的输入或者是对系统所施加的复杂
- 缓存

# 2.2 模型

## 2.2.1 受测系统

受测系统（SUT，system under test）的性能如图所示。

![](img/ch2/system-under-test.png)

扰动（perturbation）是会影响结果的，扰动包括系统其他用户、其他的复杂等。

## 2.2.2 排队系统

![](img/ch2/queue-model.png)


# 2.3 概念

## 2.3.1 延时

延时是操作执行之前的等待时间，响应时间包括了延时和操作时间。

延时可以在不同点观测，所以要指明观测的对象。例如，网站的载入时间由三个不同的点观测的时间组成：DNS 延时，TCP 连接延时和 TCP 传输时间。

## 2.3.2 时间量级

系统各组件的延时

| 事件                      | 延时        | 相对时间比例 |
| ------------------------- | ----------- | ------------ |
| 1个CPU周期                | 0.3 ns      | 1 s          |
| L1 缓存访问               | 0.9 ns      | 3 s          |
| L2 缓存访问               | 2.8 ns      | 9 s          |
| L3 缓存访问               | 12.9 ns     | 43 s         |
| 主存访问                  | 120 ns      | 6 分         |
| 固态硬盘 I/O              | 50 - 150 us | 2-6 天       |
| 旋转磁盘 I/O              | 1 - 10 ms   | 1-12 月      |
| 互联网：旧金山 - 纽约     | 40 ms       | 4 年         |
| 互联网：旧金山 - 澳大利亚 | 183 ms      | 19 年        |
| TCP 包重传                | 1 - 3 s     | 105 - 317 年 |
| 物理系统重启              | 5 m         | 32 千年      |

## 2.3.3 权衡三角

性能/及时/成本低，这三样，最多只能获得两个。

一个常见的权衡是 CPU 和内存，内存可以缓存结果，降低 CPU 的使用。CPU 可以压缩数据来降低内存的使用。

## 2.3.4 调整的影响

性能调整发生在越靠近工作执行的地方，就越有效。

| 层级     | 调优对象                               |
| -------- | -------------------------------------- |
| 应用程序 | 执行的数据库请求                       |
| 数据库   | 数据库表的Schema、索引、缓冲           |
| 系统调用 | 内存映射、读写、同步或异步 I/O 标识    |
| 文件系统 | 记录大小、缓存大小、文件系统的可调参数 |
| 存储     | RAID级别，磁盘类型和数目               |

## 2.3.5 合适的层级

调优的层级，取决于性能技术投入的投资回报率，大公司可能有个团队来分析性能，包括内核、CPU 性能计数器。

## 2.3.6 性能建议的时间点

环境的性能特性会随着时间改变，更多的用户、新的硬件、升级的软件都是变化的因素。

性能推荐，尤其是可调整的参数值，仅仅在一段时间内有效。

## 2.3.7 负载 VS. 架构

应用程序性能差可能是因为架构的问题，也可能是由于太多的负载，导致了排队和长延时。

![](img/ch2/overload-vs-architecture.png)

举个例子，架构的问题可能是一个单线程的应用在单个 CPU 上忙碌，但其他 CPU 却是空闲的。

负载的问题可能是一个多线程程序在多个 CPU 上都很忙碌，但请求依然排队的情况。负载超出了 CPU 能处理的范围。

## 2.3.8 扩展性

扩展性：负载增加下的系统所展现的性能。

例如，当 CPU 接近100% 的使用率时，调度延时增加，性能开始下降。

另一个发生性能下降可能是由于内存的负载，当系统开始换页来补充内存的时候。

磁盘 I/O 也会随着负载的增加而排队，增加了响应时间。

## 2.3.9 已知的未知

性能领域是“你知道的越多，你不知道的也就越多”。这些未知的未知，会变成你可以去查看的已知的未知。

## 2.3.10 指标

性能指标是由系统、应用程序、或者其他工具产生的度量。

常见的性能指标如下：

- IOPS: 每秒的 I/O 操作数
- 吞吐量：每秒的数据量或操作量
- 使用率
- 延时

性能指标不是免费的，有些时候要消耗一些 CPU 周期来收集和保存指标。

实际上，指标可能是混淆的、复杂的、不可靠的、不精确的，甚至是错的。

## 2.3.11 使用率

使用率是基于时间、或者基于容量的。

### 基于时间

基于时间的使用率是使用排队理论定义的：服务器或资源繁忙的均值，即

```
U = B/T
```

其中 `U` 是使用率，`T` 是观测周期，`B` 是 `T` 时间内系统的繁忙时间。

某些组件在使用率 100% 的时候，性能会有眼中的下降，有些则不会降地太大。

### 基于容量

系统或组件都能提供一定数量的吞吐。不论性能处于何种级别，系统或组件都工作在其容量的某一比例上。这个比例称为使用率。

## 2.3.12 饱和度

随着工作量增加而对资源的请求超过所能处理的程度，叫做饱和度。饱和度发生在 100% 使用率的时候。

## 2.3.13 Profilling

Profiling 是按照特定的时间间隔对系统的状态进行采样，然后对样本进行研究。

## 2.3.14 缓存

缓存是将比较慢的存储层的结果，存放在较快的存储层中。

缓存性能的重要指标是命中率：

```
命中率 = 命中次数 / (命中次数 + 失效次数)
```

另一个指标是失效率，即每秒缓存失效的次数。

工作负载的总运行时间计算方式为：

```
运行时间 = (命中率 * 命中延时) + (失效率 * 失效延时)
```

这里用的延时都是平均值。

常用的缓存算法：

- MRU（最近最常使用）
- LRU（最近最少使用）
- LFU（最近不常使用）
- NFU（不常使用）

缓存的热度：

- 冷：缓存是空的，或者填充的是无用的数据。冷缓存的命中率 0。
- 热：缓存中都是常用的数据，命中率很高。

- 温：缓存中包含有用的数据，但命中率没有预想的高。

# 2.4 视角

性能分析有两个常用的视角，每个视角的受众、指标和方法都不一样。

## 2.4.1 资源分析

资源分析以系统资源的分析为起点，涉及的资源有：CPU、内存、磁盘、网卡、总线以及之间的互联。

这个视角着重有使用率的分析，判断资源是否接近极限。

适合资源分析的指标：

- IOPS
- 使用率
- 吞吐量
- 饱和度

## 2.4.2 工作负载分析

工作负载分析查看 应用程序的性能：所施加的负载和应用程序时如何响应的。

工作负载分析的对象如下：

- 请求：所施加的工作负载
- 延时：应用程序的响应时间
- 完成度：查找错误

# 2.5 方法

## 2.5.1 街灯

用户选择熟悉的观测工具来分析性能，这些工具可能是网上找的，也可能是随意选择，仅仅是想看会有什么结果出现。

性能调整可以用试错的方式，对所知道的可调参数进行设置，熟悉不同的值，看看是否有帮助。

## 2.5.2 随机变动

用户随机猜测问题可能的位置，然后做改动，直到问题消失。整个方法如下：

1. 任意选择一个可变参数
2. 朝某个方向修改
3. 观测性能
4. 朝另一个方向修改
5. 观测性能
6. 步骤 3 和 5 是不是要好于基准值？如果是，保留修改，返回步骤 1

## 2.5.3 责怪他人

这个方法的步骤如下：

- 找到一个不是你负责的组件
- 假定问题和那个组件有关
- 把问题扔给负责那个组件的人
- 如果证明错了，返回步骤 1

## 2.5.4 Ad Hoc 核对清单

一步步地过一遍核对清单，这类清单是 Ad Hoc 的，基于该系统的经验。

比如运行 `iostat -x 1`检查 await 列，如果超过 10ms，说明磁盘太慢或过载。

这类清单在最短时间内提供最大的价值，且需要频繁更新。

## 2.5.5 问题陈述

询问客户以下问题：

1. 什么让你认为性能存在问题？
2. 系统之前运行的好吗？
3. 最近有什么改动？
4. 问题能用延时或运行时间来表述吗？
5. 问题影响其他的人和程序吗？
6. 环境是这样的？用了什么软硬件？什么版本？什么配置？

## 2.5.6 科学法

科学法研究问题是通过假设和试验：

1. 问题
2. 假设
3. 预测
4. 试验
5. 分析

## 2.5.7 诊断循环

诊断周期与科学方法类似：假设 -> 检验 -> 数据 -> 假设。

这个循环强调数据可以快速地引发新的假设，今儿验证和改良。

## 2.5.8 工具法

工具为导向的方法：

1. 列出可用的工具
2. 对每个工具，列出它提供的有用的指标
3. 对每个指标，列出阐释该指标可能的规划

这种方法的视野也不完整，通常不太高效。

## 2.5.9 USE 方法

USE 方法（Utilization，Saturation，Errors）用识别系统瓶颈：

对于所有的资源，检查它的使用率、饱和度和错误。

与工具法相反的是，USE 列举的是资源，而不是工具。这会帮助你得到一张完整的问题列表，在你寻找工具的时候做确认。

USE 方法会引导你到一定数量的关键指标上，这样可以尽快核实所有的系统资源。

| 资源     | 类型   | 指标                             |
| -------- | ------ | -------------------------------- |
| CPU      | 使用率 | CPU使用率                        |
| CPU      | 饱和度 | 分配队列长度                     |
| CPU      | 错误   | 例如，可修正的 CPU 缓存 ECC 事件 |
| 内存     | 使用率 | 可用空闲内存                     |
| 内存     | 饱和度 | 匿名换页或线程换出，或OOM事件    |
| 内存     | 错误   | 例如，失败的 malloc              |
| 网络接口 | 使用率 | 吞吐量、最大带宽                 |
| 存储设备 | 使用率 | 设备繁忙百分比                   |
| 存储设备 | 饱和度 | 等待队列长度                     |
| 存储设备 | 错误   | 设备错误（硬错误、软错误）       |

软件资源：

- 互斥锁
- 线程池
- 进程/线程容量
- 文件描述符容量：针对问题件描述符的上限

## 2.5.10 工作负载特征归纳

这个方法关注系统的输入，而不是所产生的性能问题：

- 负载是谁产生的？
- 负载为什么会被调用？
- 负载的特征是什么？
- 负载是怎样随着时间变化的？

最好的性能来自消灭不必要的工作。

## 2.5.11 向下挖掘分析

深度分析分为以下阶段：

1. 检测：用于持续记录高级层的统计数据
2. 识别：对于给定问题，缩小研究的范围，找到可能的瓶颈
3. 分析：对特定的系统部分作进一步的检查，找到问题并量化

## 2.5.12 延时分析

延时分析检查完成一项操作的时间，然后把时间再分成小的时间段。接着对最大延时的时间段再做划分，最后定位并量化问题的根本原因。

分析可以由工作负载开始，检查负载是如何在程序中被处理的，然后深入操作系统的库、系统调用、内核以及设备驱动。

比如，MySQL 的请求延时可能涉及如下问题：

1. 存在请求延时吗？
2. 请求时间大量地花在 CPU 上吗？
3. 不花在 CPU 上的时间在等什么？
4. 文件系统的 I/O 时间是花在磁盘 I/O 上还是竞争锁上？
5. 磁盘 I/O 时间主要是随机寻址的时间还是数据传输的时间？

## 2.5.13 R 方法

R 方法是针对 Oracle 数据库，基于 Oracle 的 trace events，着重于识别和量化查询过程中的时间消耗。

## 2.5.14 事件跟踪

系统的操作就是处理离散的事件，如 CPU 指令、磁盘 I/O、系统调用等。

网络排错常常要逐包检查差，推荐 tcpdump。系统调用层的工具有 strace 和 truss。

## 2.5.15 基准线统计

把当前的性能指标与之前的数值作对比，对分析问题常有启发啊。

## 2.5.16 静态性能调整

静态性能分析处理的是架构的问题，它是在系统空闲的时候进行的：

- 该组件是需要的吗？
- 配置是针对预期的负载设定的吗？
- 组件的自动配置对预期的负载是最优的吗？
- 有组件出现错误吗？

## 2.5.17 缓存调优

各级缓存的调优策略：

1. 缓存的大小尽量和栈的高度一样，靠近工作执行的地方，减少命中缓存的资源开销
2. 确认缓存正常工作
3. 确认命中率和失效率
4. 如果缓存是动态的，确认它的当前大小
5. 针对工作负载调整缓存
6. 针对缓存调整工作负载

## 2.5.18 微基准测试

微基准测试测量的是试驾了简单的人造负载的性能。它可以用以支持科学方法的假设和测试。

以下是一些微基准测试的例子：

- 系统调用：针对 `fork()`/`exec()`/`read()`
- 文件系统读取
- 网络吞吐量

# 2.6 建模



