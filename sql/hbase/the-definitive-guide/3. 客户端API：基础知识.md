HBase 是 Java 编写的，所以原生的 API 也是 Java 开发的。

# 3.1 概述

HBase 的主要客户端接口是由 `org.apache.hadoop.hbase.client`包中的`HTable`类提供的。通过这个类，用户可以存储、检索、删除数据。

所有的修改操作都是**原子性**的。这会影响到**这一行**数据的所有并发读写操作。这意味着

> 其他客户端或线程对同一行的读写操作不会影响该行数据的原子性，要么读到最新的修改，要么等待系统允许写入该行。

行原子性会保护到该行的**所有列**。

当然，创建`HTable`是有代价的，每个实例都要扫描`.META`表，以确定该表是否存在、是否可用。这些检查非常耗时。建议复用`HTable`对象。

如果需要多个`HTable`实例，考虑`HTablePool`类。

# 3.2 CRUD 操作

## 3.2.1 `Put` 方法

### 1. 单行`put`

```java
void put(Put put) throws IOException
  
// Put 构造函数
Put(byte[] row)
  
// 向 Put 实例添加数据
// ts 时间戳为可选参数，忽略的话，Region Server会填充之。
Put add (byte[] family, byte[] qualifer, long ts, byte[] value)
  
// 检查是否存在特定的单元格
boolean has(byte[] family, byte[] qualifer, long ts)
```

### 2. `KeyValue`

`KeyValue`提供了一系列实现`Comparator`接口的内部类。

### 3. 客户端的写缓冲

每一个`put`操作实际上是一个RPC请求。HBase的API配备了客户端的写缓冲区。缓冲区负责收集`put`操作，然后调用RPC操作一次性将`put`送往服务器。全局交换机控制着该缓冲区是否在使用：

```java
void setAutoFlush(boolean autoFlush)
bool isAutoFlush
```

默认情况下，客户端的缓冲区是禁用的，除非：

```java
table.setAutoFlush(false)
```

缓冲区仅在两种情况下会刷写：

1. 显式：`flushCommits`
2. 隐式：用户调用`put`或`setWriteBufferSize`时触发。如果缓冲区超过限制，会自动触发。`close()`会无条件触发。

### 4. `Put`列表

客户端的API可以批量处理操作：

```java
void put(List<Put> puts) throws IOException
```

### 5. 原子性操作 compare-and-set

有一种特别的`put`调用，能够保证自身操作的原子性：检查写（check and put）：

```java
boolean checkAndPut(byte[] row, byte[] family, byte[] qualifier, byte[] value, Put put) throws IOException
```



## 3.2.2 `get`方法

