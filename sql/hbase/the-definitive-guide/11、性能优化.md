# 11.1 垃圾回收

垃圾回收时 master 通常不会产生问题，因为 master 没有处理过重的负载。

memstore 写入磁盘的数据是客户端在不同时间写入的，它占据的堆空间可能是不连续的，JVM 的堆内存就会出现空洞。

数据会根据在内存中停留的时间被保存在 Java 堆中分代结构的不同位置：被快速插入且被刷写到磁盘中的数据，被分配到年轻代（young generation）或新生代（new generation）的堆中。这种空间可以被迅速回收，对内存管理没有影响。

如果数据再内存中停留时间过长，对应的数据就提升为老生代（old generation）或终生代（tenured generation）。年轻代和老生代的不同点在于空间代销：年轻代占用的空间在128M ~ 512M。老生代机会占据了所有的堆内存。

指定新生代的空间：

```
-XX:MaxNewSize=128m -XX:NewSize=128m
// 等同于
-Xmn128m
```

强烈建议在 JRE 日志中输出垃圾回收的详情，用户可以添加一下的 JRE 选项：

```
-verboseL:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XLoggc:hbase.log
```

用户也可以指定 GC 策略，推荐的是：

```
-XX:+UseParNewGC 和 -XX:+UseConcMarkSweepGC
```

UseParNewGC 将停止运行 Java 进程而去清空年轻代堆。这个花费很短时间。这个策略对较小的年轻代可以接受，但不适合老生代。在最差的情况，以上回收策略会造成树苗的停顿。

UseConcMarkSweepGC 是并行标记回收器，它在工作时不停止运行 Java 进程，尽可能异步完成操作。CMS 还有一个额外的开关选项，控制什么时候触发标记清理：

```
-XX:CMSInitiatingOccupancyFraction=70
```



# 11.2 本地 memstore 分配缓冲区

HBase 0.90引入了一种高级机制来缓解 region server 内存碎片的问题，这个问题是由于不断创建和释放内存空间造成的：本地 memstore 分配缓冲区（Memstore-Local Allocation Buffers，MSLAB）。

MSLAB 只允许从对中分配相同大小的对象，一旦这些对象分配并且最终被回收，它们将在堆中留下固定大小的空洞。之后调用相同大小的新对象会重新使用这些空洞。

MSLAB 的代价是可能会更加浪费堆空间，因为用户不可能把缓冲区都用到最后一个字节。



# 11.3 压缩

HBase支持列族以上级别的数据压缩。推荐开启压缩，CPU 压缩和解压消耗的会见比从磁盘中读取和写入消耗的时间更短。

## 11.3.1 可用的编解码器

HBase 没有提供嵌入式的压缩算法，用户需要提前编译构建。

| 算法           | 压缩 % | 压缩 MB/s | 解压 MB/s |
| ------------ | ---- | ------- | ------- |
| GZIP         | 13.4 | 21      | 118     |
| LZO          | 20.5 | 135     | 410     |
| Zippy/Snappy | 22.2 | 175     | 409     |

GZIP 在压缩上有优势，但也是 CPU 密集型算法，不推荐。

Snappy 有和 LZO 一样的质量，并有兼容的许可使用。推荐 Snappy。



# 11.4 优化拆分和合并

## 11.4.1 管理拆分

HBase 是自动处理 region 拆分的：一旦它们达到既定的阈值，region 就会被拆分为两个。

用户可以使用`split`和`major_compact`来手动拆分，最好在不同的 region 上交错进行，可以避免拆分/合并风暴。

## 11.4.2 region 热点

用户最好采用盐析主键（salt-key）或使用随机的行键来负载均衡。

缓解region 热点的途径就是手动拆分 region。

## 11.4.3 预拆分 region

`createTable`的时候，输入`SPLITS`参数。



# 11.5 均衡负载

