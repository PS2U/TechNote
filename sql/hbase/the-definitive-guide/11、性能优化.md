# 11.1 垃圾回收

垃圾回收时 master 通常不会产生问题，因为 master 没有处理过重的负载。

memstore 写入磁盘的数据是客户端在不同时间写入的，它占据的堆空间可能是不连续的，JVM 的堆内存就会出现空洞。

数据会根据在内存中停留的时间被保存在 Java 堆中分代结构的不同位置：被快速插入且被刷写到磁盘中的数据，被分配到年轻代（young generation）或新生代（new generation）的堆中。这种空间可以被迅速回收，对内存管理没有影响。

如果数据再内存中停留时间过长，对应的数据就提升为老生代（old generation）或终生代（tenured generation）。年轻代和老生代的不同点在于空间代销：年轻代占用的空间在128M ~ 512M。老生代机会占据了所有的堆内存。

指定新生代的空间：

```
-XX:MaxNewSize=128m -XX:NewSize=128m
// 等同于
-Xmn128m
```

强烈建议在 JRE 日志中输出垃圾回收的详情，用户可以添加一下的 JRE 选项：

```
-verboseL:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XLoggc:hbase.log
```

用户也可以指定 GC 策略，推荐的是：

```
-XX:+UseParNewGC 和 -XX:+UseConcMarkSweepGC
```

UseParNewGC 将停止运行 Java 进程而去清空年轻代堆。这个花费很短时间。这个策略对较小的年轻代可以接受，但不适合老生代。在最差的情况，以上回收策略会造成树苗的停顿。

UseConcMarkSweepGC 是并行标记回收器，它在工作时不停止运行 Java 进程，尽可能异步完成操作。CMS 还有一个额外的开关选项，控制什么时候触发标记清理：

```
-XX:CMSInitiatingOccupancyFraction=70
```

## 11.2 本地 memstore 分配缓冲区

