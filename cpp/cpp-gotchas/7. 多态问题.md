# 类型特征码

在面向对象思想中，对象的类型由其行为决定，而非由其状态决定。以数据成员的方式表示类型特征码，多此一举。

对象的类型一经初始化，便矢志不渝。

不要以数据成员的形式存储特征码，要使用虚函数代替它。

 

# 将基类析构函数声明为非虚函数

如果基类类型未将析构函数声明为虚函数，那么经由基类接口来析构派生类对象现在将带来未定义的恶果。

class Base

{

Resource *br;

~Base(){delete br;}

};

class Derived:public Base

{

OtherResource *dr;

~Derived(){delete dr;}

}

Base *bp = new Base;

delete bp; //没事

bp = new Derived;

delete bp; //灾难！

 

# 对非虚（成员）函数的遮掩

非虚（成员）函数指定了以基类为根的继承谱系中的不变量。

虚函数和纯虚函数就是指定（成员函数之行为）实现依类型之可变性的机制。

装饰器模式。

 

# 过分灵活的模版模式

模版模式将算法分离成不变部分和可变部分。

 

# 重载虚函数

避免重载虚函数并不会将基类接口带来的任何剧烈的约束。

 

# 为参数指定默认和初始化物的虚函数

避免在虚函数中提供参数默认初始化物。

 

# 在构造函数和析构函数中调用虚函数

为基类子对象截取或清算资源的代码就应该放在（基类类型的）构造函数和析构函数里，不要企图让基类代理派生类的资源管理之责。

 

# 虚赋值

赋值运算符声明为虚函数是合法的，但是虚赋值却鲜有其合理之处。

派生类类型中即使写了复制赋值运算符，也并不是对基类类型中的复制赋值运算符的改写。

通常，虚复制构造比虚赋值更好的设计思路，虚构造函数，也被称之为原型模式。

 

# 未能区分函数的重载、改写和遮掩

重载，不同的函数使用同一标识符，并且这些函数位于同一作用域。

派生类类型中的process函数声明在派生类作用域中，而并非基类作用域中，因此它不和基类中的函数形成重载关系。



# 导航

[目录](README.md)

上一章：[6. 内存和资源管理问题](6. 内存和资源管理问题.md)

下一章：