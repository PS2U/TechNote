# 未能区分纯量和数组的内存分配机制

w = new W(arg);//纯量

w = new W[n]; //数组

new运算符的行为不可以通过重载来改变，它总是会调用operator new函数。

当vector被析构时，是从头到尾开始析构的，这与数组的析构相反。

编译器标识不出针对纯量的普通delete的误用，因为它分辨不出指针究竟指向了数组还是一个纯量元素。

 

# 内存分配失败校验

标准的new运算符是在分配失败时抛出一个bad_alloc异常。

任何情况下，校验标准形式new运算符之调用的返回结果都不能起到检测错误的功效。

 

# 替换全局的内存管理运算符

operator new和operator delete可以重载。

最好的做法是：不要遮掩任何全局作用域内的内存管理函数。

 

# 成员版本的operator new和operator delete的作用域和调用机制混淆

内存分配（表达式）所在的作用域是无关紧要的，是要求内存分配的对象类型决定了那个函数被调用。

 

# 抛出字符串字面常量作为异常对象

异常对象被捕获依据的是它们的类型，而不是值。

抛出异常也就隐式的说明该对象允许复制构造，该被复制构造了的对象也必须在被处理之后被析构。

最好的做法是直接从标准库中的异常类型派生出自己的异常类型。

 

# 未能理解和利用异常处理机制

不要抛出指针，抛出对象，哪怕是匿名对象。

catch子句是依其出现次序被加以检视的，次序应该是具象到抽象这样安排。

 

# 滥用局部量地址

消逝的栈帧，如果一个变量是auto的，在函数返回时它占用的存储就会被回收。

若一个（局部）变量被声明为静态的，那么未来对于（该局部变量位于其作用域中的）同一函数的调用就会影响到先前的调用取得的结果。

不要返回指向在函数作用域内所分配之存储的引用。

返回指向（函数作用域内分配的）存储的指针，或干脆不要分配存储，直接以传值方式返回。

 

# 未能采用RAII（资源获取即初始化）习惯用法

 

# 对auto_ptr的误用

标准库的auto_ptr是相当有用的、为从堆上分配的对象准备的通用型资源句柄。

对auto_ptr的使用有两种错误：

1、错误地假定auto_ptr可以指向数组。

2、使用auto_ptr（实例化类型）作为STL容器的基本类型。

# 导航

[目录](README.md)

上一章：[5. 初始化问题](5. 初始化问题.md)

下一章：[7. 多态问题](7. 多态问题.md)