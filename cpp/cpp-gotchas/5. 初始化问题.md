# 赋值与初始化混淆

初始化，就是把一段raw storage变成一个对象的过程。赋值，是在一个well-defined对象的某种状态上所做的一个转换，使得它处于一个新的状态。

参数的按值传递是由初始化操作完成的，而非赋值操作。

赋值操作和复制构造器，两者有其一，必有其二。

T b = a; 这是初始化，不是赋值，=不是赋值运算符。

 

# 位于非适当作用域的变量

声明可以写在语句能够出现的任何位置。

把一个名字精确地钳制在原始作者意图让其发挥作用的那个作用域中。

 

# 未意识到复制操作的固有行为

复制赋值操作和复制构造函数（以及其他任何的构造函数、所有的析构函数）都是不从基类继承的，所有的class都得定义自己的复制操作。

复制构造函数的默认实现，就是执行一个按成员进行的初始化操作。

仅声明private的复制操作，但不给出定义，编译器不再隐式提供一个复制操作实现。

 

# 按位复制的class对象

手动按位复制的实现，一般都有问题，还是让编译器自己来吧。

 

# 未能区分构造函数中的初始化和赋值

要求初始化的成员包括常量、引用、具有构造函数的class类型的对象以及基类类型的子对象。

在构造函数的函数体中做初始化操作，相对于赋值，宁使用成员初始化列表。

有两种数据成员是不允许在成员初始化列表中进行的：静态数据成员和数组。

 

# 未能在成员初始化列表中保持次序一致性

class的任何构造函数必须按照这样的次序来初始化其各个组成部分。

(1) 虚基类的值对象，无论它在继承类型中位于何处。

(2) 非虚直接基类，该次序取决于它们在基类中的成员列表中的位置。

(3) 本class的数据成员，按其声明次序。

 

# 对于虚基类（子对象）进行默认初始化

典型的，存放虚基类子对象的共享存储是在完整对象之后的。

用static_cast将虚基类对象转换至其派生类是不合法的，但是reinterpret_cast和dynamic_cast是可以的。

 

# 复制构造函数对基类子对象初始化的未预期行为

一旦你决定从编译器手里收回权力，亲自来撰写这些（不从基类继承的、独一无二的）成员函数，你就得全盘接手，不能半推半就。

 

# 运行期静态初始化次序

所以C++代码中的静态数据都会在被访问之前完成初始化，如果没有指定初始化，会以全零模式初始化。

静态class对象的默认初始化（列表）同样会引发运行期静态初始化，最好的预防办法就是尽可能减少外部链接的变量，包括静态的class数据成员。

Schwarz计数器，显式地将初始化次序以代码的形式固定下来。

 

# 直接与复制初始化

```c++
class Y

{

public :

Y(int);

~Y();

};

Y a(1066);

Y b = Y(1066);

Y c = 1066;
```

三操作产生相同的目标码，对a叫直接初始化，通过调用Y::Y(int)完成。b和c都是复制初始化，对于b，先产生一个Y类型的匿名临时变量，以1066初始化，然后将它用作Y类型的复制构造函数的参数来完成对b的初始化，最后再调用析构函数将匿名对象析构。对c也是。

应该尽量使用直接初始化。

 

# 对参数的直接初始化

参数的传递是以复制初始化实现的。对形参的初始化都会包括一个临时对象的构造、形式参数的复制构造，先在函数返回时，显式形式参数被析构，接着临时对象也被析构。

尽一切可能避免把class对象以传值方式做参数传递，应该偏好用指向常量的引用方式传递。

 

# 无视返回值优化

```c++
string operator +(const String &lhs, const String &rhs)

{

String temp(lhs);

temp += rhs;

return temp;

}
```

这段代码的的实际效果如下

```c++
string operator +(String &dest, const String &lhs, const String &rhs)

{

String temp(lhs);

temp += rhs;

dest.String::String(temp);

temp.~String();

}
```

编译器实际上将返回值的目的数据区作为函数的一个隐式的额外参数。

对于class对象而言，以函数返回值为初始化物，要比以函数的返回值对其赋值来的高效。

永远都不应该对未初始化的存储赋值。

 

# 在构造函数中初始化静态（数据）成员

静态数据成员有着外部的连接而仅仅作用于其宿主class的作用域。

构造函数中的是不能初始化静态数据成员的，因为一旦代码到了构造函数体，就不可能做任何初始化的工作，只能赋值。



# 导航

[目录](README.md)

上一章：[4. 类型转换问题](4. 类型转换问题.md)

下一章：[6. 内存和资源管理问题](6. 内存和资源管理问题.md)