# set和get状态接口

```c++
int getValue() const
{ return value; }

void setValue(int value)
{ this.value = value; }
```
 

# 常量和引用数据成员

带有尽可能多的常量，但过犹不及。

考虑为内含指向其他数据的句柄（通常是指针或引用）的class任何自行撰写复制构造函数。

赋值给常量是非法的。

 

# 未能理解常量成员类型

关键词const出现在函数首部后面指示了带有常量性的是函数本身，而不是其返回值类型。

常量成员函数实现了（其从属对象）的“逻辑常量性”。在调用它前后，可见的class对象状态不会改变，即使其物理状态上被改变了。

 

# 未能区分强聚合和弱聚合

非适当的运算符重载。

运算符重载的意义，只是为了使得代码以基本和通用的形式使之更可读，而不是为了基于设计工程师以卖弄的资本。

除非重载一个运算符比使用非运算符版本明显更佳，否则就不要重载运算符。

 

# 运算符优先级和重载

运算符的优先级也是其接口的组成部分，请保证重载运算符的优先级复合用户的期望。

 

# 友元与成员运算符

重载运算符理应允许隐式转换至参数类型的任何可能的类型转换得以实施。

非成员友元允许在其第一个参数上施行（任何合法的）类型转换，而成员函数则之允许进行基于皆然关系的类型转换。

 

# 自增自减运算符的问题

Iter &operator ++(); //前置

Iter operator ++(int); //后置

前置返回一个可修改的左值，以模拟内建运算符的行为。

后置一般利用其前置版本实现。

C++中，前置总是优于后置。

用户自定义版本的后置形式的自增自减运算符若要给出一个更安全的实现，应该返回常量。

大多数的自增自减运算符以成员函数手法实现。但对枚举类型并不适用。

 

# 对模版化的复制操作的认识误区

模版成员函数决不会为完成复制操作而实例化。

复制操作不经由模版成员函数来完成。


# 导航

[目录](README.md)

上一章：[7. 多态问题](7. 多态问题.md))

下一章：[9. 继承谱系设计问题](9. 继承谱系设计问题.md)
