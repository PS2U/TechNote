# 模板定义

函数模版

```c++
template<typename T> inline int compare(const T &v1, const T &v2)
{
	if(v1 < v2) return -1;

	if(v2 < v1) return 1;

	return 0;
}
```

类模版 `template<class Type> class Queue{};`

使用类模版 `Queue<int> qi;`

模版形参的作用域：在声明为模版形参之后直到模版声明或定义的末尾处。

模版形参遵循常规名字屏蔽规则。

用作模版形参的名字不能在模版内部重用。

同一模版的声明和定义中，模版形参的名字不必相同。

模版类型形参前面必须带上关键字class或typename（相同涵义），非类型形参前面必须带上类型名字，省略关键字或类型说明符是错的。

 

# 实例化

模版在使用时进行实例化。类模版在引用实际模版类类型时实例化，函数模版在调用它或用它对函数指针进行初始化或赋值时实例化。

类模版的每次实例化都会产生一个独立的类类型。为int实例化的Queue与任意其他Queue类型没有关系，也没有访问权。。

类模版的形参是必须的。

多个类型形参的实参必须完全匹配。

可以使用函数模版对函数指针进行初始化和赋值。

 

# 模版编译模型

包含编译模型 – 编译器必须看到用到的所有模版的定义。通过在声明函数模版或类模版的头文件中添加一条#include指示使定义可用。

分别编译模型 – 编译器会为我们跟踪相关的模版定义，但我们必须让编译器知道要记住给定的模版定义。可以使用export关键字。

export指明给定的定义可能会需要在其他文件中产生实例化。

 

# 模版特化

这部分没看，暂时掠过

 

# 重载与函数模版

函数模版可以重载。

当重载函数中，既有普通函数，又有模版函数，确定函数调用的步骤如下：

1. 为这个函数名建立候选集合，包括

   a) 与被调函数名字相同的任意普通函数

   b) 任意函数模版实例化，在其中，模版实参推断发现了与调用中所用函数实参匹配的模版实参

2. 确定哪些普通函数是可行的，候选集合中的每个模版实例都是可行的，因为有模版实参推断

3. 如果需要转换来进行调用，根据转换的种类排列可行函数

   a) 如果只有一个函数可选，则调用之

   b) 如果调用有二义性，从可行函数中去掉所有函数模版实例

4. 重新排列函数模版中的可行函数

   a) 如果只有一个函数可选，就调用

   b) 否则，二义性


# 导航

[目录](README.md)

上一章：[15. 面向对象编程](15. 面向对象编程.md)

下一章：[17. 用于大型程序的工具](17. 用于大型程序的工具.md)

